#!/usr/bin/ruby

# http://www.facebook.com/careers/puzzles.php?puzzle_id=8
# Joep Kerbosch and Coenraad Bron came up with Bron-Kerbosch, I'm just a 
# hack going through the motions of solving algorithmic puzzles.
# Facebook Puzzle Bot, you a cruel mistress.
# - Vincent Woo, 2010 

$sets = []              #output of sets
$sparse = {}            #sparse adjacency matrix
$degen = []             #degeneracy ordering

def ingest(input)
    File.foreach(input) do |line|
        line.strip!
        next if line.empty?
        from, to = line.split("\t")[1..2]
        next if from == to
        $sparse[to] ||= {}
        $sparse[from] ||= {}
        if $sparse[to][from].nil?
            $sparse[from][to] = false
        elsif not $sparse[to][from]
            $sparse[to][from] = $sparse[from][to] = true
        end
    end
    $sparse.merge!($sparse) {|k, row| row.reject{|k, v| !v}.keys}
end

def generate_degeneracy_ordering
    d = []  #degree buckets
    dw = {} #degree for each vertex
    $sparse.each_pair do |vertex, neighbors|
        deg = neighbors.size
        d[deg] ||= []
        d[deg].push vertex
        dw[vertex] = deg
    end
    d.each_index {|i| d[i] ||= []}
    $sparse.size.times do
        vertex = d.find {|x| !x.empty?}.pop
        $degen.push vertex
        for neighbor in $sparse[vertex]
            if d[dw[neighbor]].delete neighbor
                dw[neighbor] -= 1
                d[dw[neighbor]].push neighbor
            end
        end
    end
end

def bron_kerbosch(set, points, exclude, pivot=nil)
    if points.empty?
        $sets.push set.sort.join(', ') if set.size > 2 and exclude.empty?
        return
    end
    pivot ||= (points + exclude).max_by {|n| $sparse[n].size}
    points.each_index do |i|
        next if $sparse[points[i]].include? pivot
        bron_kerbosch(set + [points[i]],
                     points & $sparse[points[i]],
                     exclude & $sparse[points[i]])
        exclude.push points[i]
        points[i] = nil
    end
end

exit unless ARGV.size == 1
ingest(ARGV[0])
generate_degeneracy_ordering
$degen.each_index do |vertex|
    intersect = $degen[vertex+1..$degen.length-1] & $sparse[$degen[vertex]]
    bron_kerbosch([$degen[vertex]],
                  intersect,
                  $degen[0,vertex] & $sparse[$degen[vertex]],
                  intersect.last) #last elements in $degen have highest degrees
end

$sets.sort.each {|line| puts line}