#!/usr/bin/ruby

def ingest(input)
    f = File.open input, "r"
    $num = f.gets.to_i
    nodes = {}
    $probs = Array.new $num
    $weights = Array.new($num) {|i| Array.new($num) {|j| i == j ? 0 : Float::MAX}}
    $num.times do |i|
        line = f.gets.split
        nodes[line.first] = i
        $probs[i] = line.last.to_f
    end
    f.gets.to_i.times do
        line = f.gets.split
        x, y = line[0..1].collect{|n| nodes[n]}
        $weights[x][y] = $weights[y][x] = line.last.to_f
    end
    f.close
end

def floyd_warshall
    $next = Array.new($num) {|i| Array.new($num)}
    for k in 0..$num-1
    for i in 0..$num-1
    for j in 0..$num-1
        if $weights[i][k] + $weights[k][j] < $weights[i][j]
            $weights[i][j] = $weights[i][k] + $weights[k][j]
            $next[i][j] = k
        end
    end
    end
    end
end

def solveable
    (1..$num-1).select {|i| $probs[i] > 0 and $weights[0][i] == Float::MAX}.empty?
end

def solve
    relevant = (1..$num-1).select {|n| $probs[n] > 0}
    hash = {}
    hash[[0]] = {0 => [0, 0]}
    for size in 1..relevant.size
        relevant.combination(size).each do |subset|
            subset.insert 0, 0
            hash[subset] = {0 => [Float::MAX, Float::MAX]}
            for j in subset
                next if j == 0
                reduced = subset - [j]
                hash[subset][j] = reduced.collect {|i|
                    e, t = hash[reduced][i]
                    t += $weights[i][j]
                    [e + t * $probs[j], t]
                }.min {|a,b| a.first <=> b.first}
            end
        end
    end
    hash[[0] + relevant].values.collect {|x| x.first}.min
end

ingest(ARGV[0])
floyd_warshall

unless solveable
    puts "-1.00"
    exit
end

puts "%.2f" % solve
