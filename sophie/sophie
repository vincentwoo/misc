#!/usr/bin/ruby
require 'set'
require 'heap'

def ingest(input)
    f = File.open input, "r"
    $num = f.gets.to_i
    nodes = {}
    $probs = Array.new $num
    $weights = Array.new($num) {|i| Array.new($num) {|j| i == j ? 0 : Float::MAX}}
    $num.times do |i|
        line = f.gets.split
        nodes[line.first] = i
        $probs[i] = line.last.to_f
    end
    f.gets.to_i.times do
        line = f.gets.split
        x, y = line[0..1].collect{|n| nodes[n]}
        $weights[x][y] = $weights[y][x] = line.last.to_f
    end
    f.close
end

def floyd_warshall
    $next = Array.new($num) {|i| Array.new($num)}
    for k in 0..$num-1
    for i in 0..$num-1
    for j in 0..$num-1
        if $weights[i][k] + $weights[k][j] < $weights[i][j]
            $weights[i][j] = $weights[i][k] + $weights[k][j]
            $next[i][j] = k
        end
    end
    end
    end
end

def links(i, j)
    k = $next[i][j]
    return k if k.class == Set
    $next[j][i] = $next[i][j] = (k.nil? or i == j) ?
        Set.new([]) :
        (links(i, k) + Set.new([k]) + links(k, j))
end

def solveable
    (1..$num-1).each{|i|
        return false if $probs[i] > 0 and $weights[0][i] == Float::MAX
    }
    true
end

def solve
    queue = MinHeap.new
    queue.push 0.0, [[0], Set.new((1..$num-1).select {|n| $probs[n] > 0}), 0.0, 0.0]
    while not queue.empty?
        node, remain, time, expected = queue.pop
        #puts "%.2f" % expected + "[#{time}]"
        if remain.empty?
            p node
            return expected 
        end
        remain.select {|n|
            (links(node.last, n) & remain).empty?
        }.each do |n|
            new_time = time + $weights[node.last][n]
            new_expected = expected + $probs[n] * new_time
            #puts "queuing #{node.join ' '} to #{n} adding #{$probs[n]} * #{new_time} to #{expected}. rem: #{(remain - [n]).to_a.join ' '}"
            queue.push new_expected, [node + [n], remain - [n], new_time, new_expected]
        end
    end
end

ingest(ARGV[0])
floyd_warshall

unless solveable
    puts "-1.00"
    exit
end

puts "%.2f" % solve
